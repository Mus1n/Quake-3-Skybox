<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
	
	<title>Q3 Skybox – Panorama to Cubemap</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Free online tool to convert equirectangular panorama images into 6-wall Quake 3 Arena skyboxes. Generate cubemaps instantly, rotate yaw/pitch, download as ready textures.">
	<meta name="keywords" content="quake 3, skybox generator, q3 skybox, cubemap generator, panorama to cubemap, quake tools, game dev, skybox maker, equirectangular to cubemap">
	<meta name="author" content="Musin">
	<meta name="robots" content="index,follow">
	<meta name="theme-color" content="#000000">
	<link rel="canonical" href="https://mus1n.github.io/Quake-3-Skybox/">
	
	<meta property="og:title" content="Quake 3 Skybox Generator">
	<meta property="og:description" content="Convert 2:1 panoramic images into Quake 3 Arena cubemaps instantly. Free, browser-based tool.">
	<meta property="og:url" content="https://mus1n.github.io/Quake-3-Skybox/">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://mus1n.github.io/Quake-3-Skybox/preview.png">
	
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="Quake 3 Skybox Generator">
	<meta name="twitter:description" content="Convert panoramas into Q3 cubemaps instantly. No installation. Free.">
	<meta name="twitter:image" content="https://mus1n.github.io/Quake-3-Skybox/preview.png">

	

<style>
  :root{
    color-scheme: dark;
    --black:#000000;
    --white:#FFFFFF;
    --red:#FF0000;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    min-height:100vh;
    background:var(--black);
    color:var(--white);
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    display:flex;
    justify-content:center;
    padding:16px;
  }
  .app{
    width:100%;
    max-width:1180px;
    background:var(--black);
    border-radius:18px;
    border:1px solid rgba(255,255,255,0.15);
    box-shadow:0 18px 45px rgba(0,0,0,0.9);
    padding:18px 20px 16px;
  }
  h1{
    font-size:1.25rem;
    text-transform:uppercase;
    letter-spacing:.12em;
    margin-bottom:4px;
  }
  h1 span{color:var(--red);}
  .subtitle{
    font-size:.8rem;
    color:rgba(255,255,255,0.7);
    margin-bottom:10px;
  }
  .subtitle strong{color:var(--white);}
  .subtitle code{
    background:rgba(255,255,255,0.05);
    padding:1px 5px;
    border-radius:4px;
    border:1px solid rgba(255,255,255,0.25);
  }

  .layout{
    display:grid;
    grid-template-columns:minmax(0,2.1fr) minmax(260px,1.2fr);
    gap:14px;
  }
  @media(max-width:900px){
    .layout{grid-template-columns:1fr}
  }

  /* dropzone */
  #dropzone{
    position:relative;
    min-height:400px;
    border-radius:16px;
    border:1px dashed rgba(255,255,255,0.25);
    background:var(--black);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    cursor:pointer;
    transition:border-color .2s,box-shadow .2s,background .2s;
  }
  #dropzone.dragover{
    border-color:var(--red);
    box-shadow:0 0 0 1px var(--red);
    background:#000000;
  }
  #previewCanvas{
    max-width:100%;
    max-height:100%;
    display:block;
  }
  .drop-hint{
    position:absolute;
    inset:0;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:4px;
    pointer-events:none;
    text-align:center;
    font-size:.82rem;
    color:rgba(255,255,255,0.7);
    background:radial-gradient(circle at center,rgba(0,0,0,0.4),rgba(0,0,0,0.9));
  }
  .drop-hint strong{
    color:var(--white);
    font-size:.9rem;
  }
  .chip{
    margin-top:4px;
    display:inline-flex;
    align-items:center;
    gap:5px;
    padding:2px 8px;
    border-radius:999px;
    background:rgba(0,0,0,0.7);
    border:1px solid rgba(255,255,255,0.25);
    font-size:.7rem;
    color:rgba(255,255,255,0.8);
  }
  .chip span{
    width:6px;
    height:6px;
    border-radius:50%;
    background:var(--red);
  }

  /* controls */
  .controls{
    background:var(--black);
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.25);
    padding:10px 11px 10px;
    font-size:.85rem;
    display:flex;
    flex-direction:column;
    gap:9px;
  }
  .controls label{
    display:block;
    margin-bottom:3px;
    font-size:.8rem;
    color:var(--white);
  }
  .controls input[type=text],
  .controls input[type=number]{
    width:100%;
    padding:4px 7px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.4);
    background:var(--black);
    color:var(--white);
    font-size:.8rem;
    outline:none;
    transition:border-color .15s,box-shadow .15s,background .15s;
  }
  .controls input[type=text]:focus,
  .controls input[type=number]:focus{
    border-color:var(--red);
    box-shadow:0 0 0 1px rgba(255,0,0,0.5);
    background:#000000;
  }
  .controls small{
    font-size:.72rem;
    color:rgba(255,255,255,0.6);
  }

  .format-group{
    display:flex;
    gap:8px;
    margin-top:3px;
    font-size:.8rem;
  }
  .format-group label{
    display:flex;
    align-items:center;
    gap:4px;
    margin:0;
    color:var(--white);
  }
  .format-group input[type=radio]{accent-color:var(--red);}

  button{
    border-radius:999px;
    border:1px solid var(--red);
    background:#000000;
    color:var(--white);
    padding:7px 12px;
    font-size:.78rem;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:6px;
    text-transform:uppercase;
    letter-spacing:.12em;
    transition:background .15s,border-color .15s,transform .08s,box-shadow .15s;
  }
  button:disabled{
    opacity:.45;
    cursor:not-allowed;
    background:#000000;
    border-color:rgba(255,255,255,0.25);
    box-shadow:none;
  }
  button:hover:not(:disabled){
    background:var(--red);
    border-color:var(--red);
    box-shadow:0 0 16px rgba(255,0,0,0.6);
  }
  button:active:not(:disabled){
    transform:scale(.97);
    box-shadow:0 0 10px rgba(0,0,0,0.8) inset;
  }

  #status{
    margin-top:8px;
    font-size:.78rem;
    color:rgba(255,255,255,0.75);
    white-space:pre-wrap;
  }

  /* cube net preview – 3 rows, 4 cols middle row */
  #previewFaces{
    margin-top:8px;
    display:grid;
    grid-template-columns:repeat(4,auto);
    row-gap:6px;
    column-gap:6px;
    justify-content:center;
    align-items:center;
    justify-items:center;
  }
  #previewFaces .cell{
    text-align:center;
    font-size:11px;
    color:rgba(255,255,255,0.7);
  }
  #previewFaces canvas{
    background:#000000;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.35);
    transform-origin:center center;
  }

  /* preview-only rotations: 1st cell = _up, 6th cell = _dn */
  #previewFaces .cell:nth-child(1) canvas{
    transform:rotate(90deg);      /* _up */
  }
  #previewFaces .cell:nth-child(6) canvas{
    transform:rotate(-90deg);      /* _dn 90° left */
  }
  .credits{
    width:100%;
    text-align:center;
    margin-top:18px;
    padding-top:10px;
    border-top:1px solid rgba(255,255,255,0.25);
    font-size:13px;
    color:#aaa;
}

.credits a{
    color:#fff;
    text-decoration:none;
    font-weight:600;
}

.credits a:hover{
    color:#aa0000;
}

</style>

</head>
<body>
  <div class="app">
    <h1><span>Q3</span> SKYBOX TOOL</h1>
    <p class="subtitle">
      Convert an equirectangular 360° panorama into Quake 3 skybox faces:
      <code>_ft _bk _lf _rt _up _dn</code>.<br>
      <strong>Input:</strong> only equirectangular panoramic images with ~<strong>2:1</strong> aspect ratio.
    </p>

    <div class="layout">
      <!-- left: input / preview -->
      <div id="dropzone" tabindex="0">
        <canvas id="previewCanvas"></canvas>
        <div class="drop-hint" id="hint">
          <strong>Click / Drop / Ctrl+V image</strong>
          <div>Supported: 360° equirectangular panoramas (~2:1).</div>
          <div>Output: 6 cubemap walls ready for Quake 3.</div>
          <div class="chip"><span></span> Use high-res space / sky HDRIs for best result</div>
        </div>
      </div>

      <!-- right: controls -->
      <div class="controls">
        <div>
          <label for="nameInput">Skybox base name</label>
          <input id="nameInput" type="text" value="skybox">
          <small>Files: <code>name_ft.ext</code>, <code>name_bk.ext</code>, <code>name_lf.ext</code>, <code>name_rt.ext</code>, <code>name_up.ext</code>, <code>name_dn.ext</code></small>
        </div>

        <div>
          <label for="sizeInput">Wall size (px)</label>
          <input id="sizeInput" type="number" min="16" step="1" value="2048">
          <small>Single face resolution. Common: 512–2048.</small>
        </div>

        <div>
          <label for="angleInput">Yaw (horizontal rotation, °)</label>
          <input id="angleInput" type="number" step="1" value="0">
          <small>Rotate sky left/right.</small>
        </div>

        <div>
          <label for="pitchInput">Pitch (vertical rotation, °)</label>
          <input id="pitchInput" type="number" step="1" value="0">
          <small>Rotate sky up/down. 180° ≈ flip up/down.</small>
        </div>

        <div>
          <label>Output format</label>
          <div class="format-group">
            <label><input type="radio" name="fmt" value="jpg" checked> JPG</label>
            <label><input type="radio" name="fmt" value="png"> PNG</label>
          </div>
          <small>JPG – smaller; PNG – lossless.</small>
        </div>

        <div>
          <button id="zipBtn" type="button" disabled>Generate &amp; Download ZIP</button>
          <small><br>Creates <code>name_q3_skybox.zip</code> with 6 faces.</small>
        </div>
      </div>
    </div>
	<div class="credits">
    Made by <a href="https://t.me/Mus1nQ3" target="_blank" rel="noopener noreferrer"><strong>Musin</strong></a>
	</div>
    <div id="status"></div>

	<div id="previewFaces"></div>

  </div>

  <!-- hidden canvases -->
  <canvas id="srcCanvas" style="display:none"></canvas>
  <canvas id="panoCanvas" style="display:none"></canvas>

  <!-- JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>



<script>
  /* ================= BASIC REFS ================= */
  const dropzone      = document.getElementById('dropzone');
  const hint          = document.getElementById('hint');
  const previewCanvas = document.getElementById('previewCanvas');
  const previewCtx    = previewCanvas.getContext('2d');
  const srcCanvas     = document.getElementById('srcCanvas');
  const srcCtx        = srcCanvas.getContext('2d');
  const panoCanvas    = document.getElementById('panoCanvas');
  const panoCtx       = panoCanvas.getContext('2d');

  const nameInput   = document.getElementById('nameInput');
  const sizeInput   = document.getElementById('sizeInput');
  const angleInput  = document.getElementById('angleInput'); // yaw
  const pitchInput  = document.getElementById('pitchInput'); // pitch
  const zipBtn      = document.getElementById('zipBtn');
  const statusEl    = document.getElementById('status');
  const facesWrap   = document.getElementById('previewFaces');

  const fmtRadios   = document.querySelectorAll('input[name="fmt"]');

  const fileInputFake = document.createElement('input');
  fileInputFake.type = 'file';
  fileInputFake.accept = 'image/*';

  let hasImage = false;

  function getOutputFormat(){
    for (const r of fmtRadios){
      if (r.checked) return r.value;
    }
    return 'jpg';
  }

  /* ========== image load ========== */
  fileInputFake.addEventListener('change', () => {
    const f = fileInputFake.files[0];
    if (f) loadImage(f);
  });

  dropzone.addEventListener('click', () => {
    fileInputFake.value = '';
    fileInputFake.click();
  });

  dropzone.addEventListener('dragover', e => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  dropzone.addEventListener('dragleave', () => {
    dropzone.classList.remove('dragover');
  });
  dropzone.addEventListener('drop', e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) loadImage(file);
  });

  document.addEventListener('paste', e => {
    const items = e.clipboardData && e.clipboardData.items;
    if (!items) return;
    for (const item of items){
      if (item.type && item.type.startsWith('image/')){
        const file = item.getAsFile();
        if (file){
          loadImage(file);
          e.preventDefault();
          break;
        }
      }
    }
  });

  function loadImage(file){
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      preparePano(img);
    };
    img.onerror = () => {
      URL.revokeObjectURL(url);
      statusEl.textContent = 'Failed to load image.';
    };
    img.src = url;
  }

  function preparePano(img){
    const imgW = img.width;
    const imgH = img.height;

    srcCanvas.width  = imgW;
    srcCanvas.height = imgH;
    srcCtx.clearRect(0,0,imgW,imgH);
    srcCtx.drawImage(img,0,0);

    const panoW = imgW;
    const panoH = Math.floor(imgW / 2);
    panoCanvas.width  = panoW;
    panoCanvas.height = panoH;
    panoCtx.clearRect(0,0,panoW,panoH);
    panoCtx.drawImage(img, 0,0, panoW,panoH);

    const ratio = imgW / imgH;
    let warn = '';
    if (Math.abs(ratio - 2.0) > 0.2){
      warn = `⚠ Warning: input aspect ratio is ${ratio.toFixed(2)} (not ~2.00). ` +
             `Only equirectangular panoramas with 2:1 ratio are fully supported.`;
    }

    drawPreview();

    statusEl.textContent =
      `Loaded ${imgW}×${imgH} image.\n` +
       (warn ? warn : '');

    hasImage = true;
    zipBtn.disabled = false;
    hint.style.display = 'none';
    facesWrap.innerHTML = '';
  }

  function drawPreview(){
    const bounds = dropzone.getBoundingClientRect();
    const maxW = bounds.width  - 12;
    const maxH = bounds.height - 12;
    const pw = panoCanvas.width;
    const ph = panoCanvas.height;
    const scale = Math.min(maxW / pw, maxH / ph, 1);

    previewCanvas.width  = pw * scale;
    previewCanvas.height = ph * scale;
    previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
    previewCtx.drawImage(panoCanvas, 0,0,pw,ph, 0,0,previewCanvas.width,previewCanvas.height);
  }

  window.addEventListener('resize', () => {
    if (hasImage) drawPreview();
  });

  /* ===== helper: rotate canvas 90° clockwise ===== */
  function rotateCanvas90CW(src){
    const w = src.width;
    const h = src.height;
    const out = document.createElement('canvas');
    out.width = w;
    out.height = h;
    const ctx = out.getContext('2d');
    ctx.translate(w / 2, h / 2);
    ctx.rotate(Math.PI / 2); // 90° clockwise
    ctx.drawImage(src, -w / 2, -h / 2);
    return out;
  }

  /* ========== Equirect → Cube with yaw + pitch (optimized) ========== */
  function buildQ3Faces(faceSize, yawDeg, pitchDeg){
    const panoW = panoCanvas.width;
    const panoH = panoCanvas.height;

    const srcData = panoCtx.getImageData(0,0,panoW,panoH);
    const src = srcData.data;

    const yaw   = yawDeg   * Math.PI / 180;
    const pitch = pitchDeg * Math.PI / 180;

    const cosYaw   = Math.cos(yaw);
    const sinYaw   = Math.sin(yaw);
    const cosPitch = Math.cos(pitch);
    const sinPitch = Math.sin(pitch);

    function sample(px, py){
      px = ((px % panoW) + panoW) % panoW;
      py = Math.max(0, Math.min(panoH - 1, py));
      const x = px | 0;
      const y = py | 0;
      const idx = (y * panoW + x) * 4;
      return [
        src[idx    ],
        src[idx + 1],
        src[idx + 2],
        src[idx + 3]
      ];
    }

    function renderFace(face){
      const canvas = document.createElement('canvas');
      canvas.width  = faceSize;
      canvas.height = faceSize;
      const ctx = canvas.getContext('2d');
      const imgData = ctx.createImageData(faceSize, faceSize);
      const dst = imgData.data;

      for (let y = 0; y < faceSize; y++){
        const v = (y + 0.5) / faceSize * 2 - 1;
        for (let x = 0; x < faceSize; x++){
          const u = (x + 0.5) / faceSize * 2 - 1;

          let X, Y, Z;
          switch (face){
            case 'F': X =  u; Y = -v; Z =  1; break;
            case 'B': X = -u; Y = -v; Z = -1; break;
            case 'R': X =  1; Y = -v; Z = -u; break;
            case 'L': X = -1; Y = -v; Z =  u; break;
            case 'U': X =  u; Y =  1; Z =  v; break;
            case 'D': X =  u; Y = -1; Z = -v; break;
            default:  X = u;  Y = -v; Z = 1;
          }

          /* ==== NEW ORDER: yaw → pitch (so they combine properly) ==== */

          // yaw around Y (horizontal)
          let X1 = X * cosYaw - Z * sinYaw;
          let Z1 = X * sinYaw + Z * cosYaw;
          X = X1;
          Z = Z1;

          // pitch around X (vertical)
          let Y1 = Y * cosPitch - Z * sinPitch;
          let Z2 = Y * sinPitch + Z * cosPitch;
          Y = Y1;
          Z = Z2;

          /* ========================================================== */

          const len = Math.sqrt(X*X + Y*Y + Z*Z);
          X /= len; Y /= len; Z /= len;

          const theta = Math.atan2(X, Z);
          const phi   = Math.asin(Y);

          const uTex = (theta / (2 * Math.PI) + 0.5) * panoW;
          const vTex = (0.5 - phi / Math.PI) * panoH;

          const [r,g,b,a] = sample(uTex, vTex);
          const idx = (y * faceSize + x) * 4;
          dst[idx    ] = r;
          dst[idx + 1] = g;
          dst[idx + 2] = b;
          dst[idx + 3] = a;
        }
      }

      ctx.putImageData(imgData, 0, 0);
      return canvas;
    }

    // render faces
    const ft = renderFace('F');
    const bk = renderFace('B');
    const lf = renderFace('R');
    const rt = renderFace('L');
    let up  = renderFace('U');
    let dn  = renderFace('D');

    // dn: 90° right
    dn = rotateCanvas90CW(dn);

    // up: 270° right (three times 90°)
    up = rotateCanvas90CW(up);
    up = rotateCanvas90CW(up);
    up = rotateCanvas90CW(up);
	
    return { ft, bk, lf, rt, up, dn };
  }

  /* ========== cube net preview: 3 rows, 4 cols middle row ========== */
  function renderCubeNetPreview(faces){
    facesWrap.innerHTML = '';

    const PREV = 96;

    function addCell(row, col, key, label){
      if (!faces[key]) return;
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.gridRow = String(row);
      cell.style.gridColumn = String(col);

      const c = document.createElement('canvas');
      c.width = PREV;
      c.height = PREV;
      const ctx = c.getContext('2d');
      ctx.drawImage(faces[key], 0,0,faces[key].width,faces[key].height, 0,0,PREV,PREV);

      const cap = document.createElement('div');
      cap.textContent = label;

      cell.appendChild(c);
      cell.appendChild(cap);
      facesWrap.appendChild(cell);
    }

    //  row1:      col2 -> _up
    //  row2:  col1..4 -> _rt _ft _lf _bk
    //  row3:      col2 -> _dn
    addCell(1, 2, 'up', '_up');
    addCell(2, 1, 'rt', '_rt');
    addCell(2, 2, 'ft', '_ft');
    addCell(2, 3, 'lf', '_lf');
    addCell(2, 4, 'bk', '_bk');
    addCell(3, 2, 'dn', '_dn');
  }

  /* ========== ZIP EXPORT ========== */
  zipBtn.addEventListener('click', async () => {
    if (!hasImage) return;
    if (typeof JSZip === 'undefined'){
      statusEl.textContent = 'Error: JSZip not loaded.';
      return;
    }

    let faceSize = parseInt(sizeInput.value, 10);
    if (!Number.isFinite(faceSize) || faceSize <= 0){
      faceSize = 2048;
      sizeInput.value = String(faceSize);
    }

    const yawDeg   = parseFloat(angleInput.value);
    const pitchDeg = parseFloat(pitchInput.value);
    const yaw   = Number.isFinite(yawDeg)   ? yawDeg   : 0;
    const pitch = Number.isFinite(pitchDeg) ? pitchDeg : 0;

    const baseName = (nameInput.value || 'skybox').trim() || 'skybox';
    const fmt = getOutputFormat();
    const ext = fmt === 'png' ? 'png' : 'jpg';

    statusEl.textContent =
      `Converting panorama → cubemap faces (${faceSize}×${faceSize})…\n` +
      `Yaw (horizontal): ${yaw.toFixed(1)}°\n` +
      `Pitch (vertical): ${pitch.toFixed(1)}°.`;

    const faces = buildQ3Faces(faceSize, yaw, pitch);

    renderCubeNetPreview(faces);

    statusEl.textContent += '\nBuilding .zip…';

    const zip = new JSZip();

    async function canvasToBlob(canvas, fmt){
      return new Promise(resolve => {
        if (fmt === 'png'){
          canvas.toBlob(blob => resolve(blob), 'image/png');
        } else {
          canvas.toBlob(blob => resolve(blob), 'image/jpeg', 1.0);
        }
      });
    }

    const order = ['ft','bk','lf','rt','up','dn'];
    for (const suf of order){
      const canvas = faces[suf];
      if (!canvas) continue;
      const blob = await canvasToBlob(canvas, fmt);
      const filename = `${baseName}_${suf}.${ext}`;
      zip.file(filename, blob);
    }

    try{
      const zipBlob = await zip.generateAsync({type:'blob'});
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${baseName}_q3_skybox.zip`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 5000);
      statusEl.textContent += `\nDone: ${baseName}_q3_skybox.zip`;
    }catch(e){
      console.error(e);
      statusEl.textContent += `\nError creating zip: ${e}`;
    }
  });
</script>



</body>
</html>


